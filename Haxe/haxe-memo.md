# Haxeメモ
## 概要
- オープンソースの高級プログラミング言語
    - 高級言語 : 人間が理解しやすい記法で記述されているプログラミング言語。
        - 翻訳(コンパイル)に時間がかかる。
    - 低級言語 : コンピュータが理解しやすい記法で記述されているプログラミング言語。
        - 翻訳(コンパイル)に時間がかかる。
- 汎用言語として、JavaScript同様に、Web上で扱うことができる。
- 一つのコードから、あらゆるプラットフォーム向けのプログラムへ変換できる。
- [公式サイト](https://haxe.org/)

## 特徴
### 静的型付け
- 「動的」であるJavaScriptと違い、「静的」であるため、実行速度が速い。
- 変更やリファクタリング、追加仕様の実装が安全。

### 型推論
- 型を書かなくても、型を書いたのと同様の効果が得られる。
- コンパイラが自動的に型を判断して、型がある言語のような判断をする。

### マルチプラットフォーム
- JavaやC++、PHP、Pythonなどの言語に書き出すことができる。
- つまり、ブラウザコンテンツ、デスクトップアプリ、スマートフォンアプリ、サーバーシステムを作ることが可能。

### 複数環境でのコードの共有
- 同じコードを二回書く手間が省ける

### クラス定義での通信
- 「Serializer」という、インスタンスなどを文字列へ変換して、復元することができるクラスを持つ。
- 例として、「クライアントデータを文字列へ変換して、サーバーへ送信してから復元」といったことが可能。
    - その際の型情報は、維持されたままのため、対象クラスのインスタンスとして、扱うことができる。
    - JSON等で行われる「クライアントとサーバー間の通信方式」では、独自のクラス定義が失われるため、変数の場所等を示す仕様書が必要になってくる。
- つまり、Haxeではコードそのものが仕様書となるため、新規で作る必要がない。

## 比較
- Haxeは、JavaScriptの代替と呼ばれる`altJS(静的型付け)`の一部である。
- その部類の一つである、TypeScriptとの比較をしてみる。

### TypeScriptとの比較

||TypeScript|Haxe|
|:---:|:---:|:---:|
|**JavaScriptとの互換性**|高い<br>仕様上の欠点を数々引き継いでいる||
|**マクロ**|無し|有り|
|**列挙体**|無し|有り|
|**マルチプラットフォーム**|無し|有り|
|**パターンマッチ**|無し|有り|
|**代数的データ型**|無し|有り|

## 紹介サイト
- [Haxe紹介](https://www.slideshare.net/sipojp/haxe-24876418)

## 試用
### Try Haxe
- [Try Haxe](https://try.haxe.org/)というサイトを使えば、環境構築不要で、簡単にHaxeをブラウザで試すことができる。

## 記法
### チュートリアル
- Haxeファイルは、「.hx」のようにしていく。

```haxe
// ベースの書き方
class Hello {
    static function main () {
        trace ("Hello World");
    }
}
```

### ログ出力
- 出力は、`trace("メッセージ")`のように、行う。

```haxe
class Hello {
    static function main () {
        trace("Hello World");
    }
}
```

### コメント
- コメントは、下記の形式で行える。

```haxe
// コメント
/*
複数行
コメント
*/
```

### 変数
- 変数は、`var 変数名 = 値;`のように行う。
- 型を記述する場合、`var 変数名:型 = 値;`のように行う。
- 変数の型推論を調べる場合、`$type(変数);`のように行う。
    - ※その際は、表示ではなく、コンパイル時の警告として出力される。

```haxe
class Test {
    static function main() {
        // 型を記述しない場合。
        var message = "こんにちは";
        // 型を記述する場合。
        var count:Int = 1;
        // 変数の型を調べる場合。
        $type(message);
        // 変数の出力
        trace (message);
    }
}
```

### 型の種類
- 基本の型は、下記。

|型|意味|
|:---:|:---:|
|Int|整数|
|Float|浮動小数点数|
|String|文字列|
|Bool|真偽値|
|Array|配列|
|Map|連想配列|

### 型内容
- 型のあとに、`<>`の記述で、内容（パラメーター、ジェネリクス）の指定。
    - ※未指定でも、型推論により、型が当てはまる。**何でも入れていい配列にはならない**
- Arrayの場合、下記のように行う。

```haxe
// Int(整数)のみの配列
var testGroup:Array<Int> = [34,43,25];
// 文字列追加のため、エラー
testGroup[3] = "Hello";
```

- 何でも入れていい配列の時は、`Array<Dynamic>`のように行う。

```haxe
// var sampleGroup = [46,"Hello"];　だとエラー
var sampleGroup:Array<Dynamic> = [46,"Hello"];
```

- Mapの場合は下記。
    - ※Mapは値のアクセスが速くなるが、メモリ使用量が大きくなることがある。

```haxe
// Mapの定義
var testMap:Map<String,Int> = new Map();
// Mapの定義(初期化の場合)
var sampleMap:Map<String,Int> = ["siraishi"=>26,"kubo"=>17,"koike"=>20];
// キーと値の登録
testMap["suzuki"] = 45;
sampleMap["nibu"] = 16;
// キーから値の呼び出し
trace(testMap["suzuki"]);
trace(sampleMap["nibu"]);
```

### 型エラーの回避
- 型を明示的に回避する場合は下記。
    - 型エラーの回避行為自体は、設計が悪い可能性がある。

```haxe
// 数字等を文字列へ変換する。
var message:String = Std.string(34);
// 文字列を整数へ変換する。
var number:Int = Std.parseInt("67");
// 文字列を浮動小数点数へ変換する。
var length:Float = Std.parseFloat("3.14");
// 浮動小数点数を整数へ変換する(切り捨て)
var score:Int = Std.int(45.6);
```

- 何でも入る型として、`Dynamic`を利用する場合もある。

```haxe
// 整数代入
var a:Dynamic = 43;
// 文字列で上書き
a = "Hello";
// 型パラメータへDynamicを使用
var Group:Array<Dynamic> = [2,4,"Hello",34,"World"];
```